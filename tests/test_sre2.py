# Test SRE gaps: pos/endpos, groups(default=), groupdict(default=),
# findall multi-group, split capturing groups, template.
# Uses _sre.compile() directly with CPython-generated bytecodes.

import _sre

# ============================================================================
# Pattern bytecodes (generated by CPython's re._compiler._code)
# ============================================================================

# "hello" (0 groups) - for pos/endpos tests
hello_code = [14, 16, 3, 5, 5, 5, 5, 104, 101, 108, 108, 111, 0, 0, 0, 0, 0, 16, 104, 16, 101, 16, 108, 16, 108, 16, 111, 1]
p_hello = _sre.compile("hello", 0, hello_code, 0, {}, ())

# (hello)(?:(world)|) - BRANCH-based optional group (2 groups)
hello_opt_code = [14, 16, 1, 5, 10, 5, 0, 104, 101, 108, 108, 111, 0, 0, 0, 0, 0, 17, 0, 16, 104, 16, 101, 16, 108, 16, 108, 16, 111, 17, 1, 7, 17, 17, 2, 16, 119, 16, 111, 16, 114, 16, 108, 16, 100, 17, 3, 15, 5, 3, 15, 2, 0, 1]
p_hello_opt = _sre.compile("(hello)(?:(world)|)", 0, hello_opt_code, 2, {}, ())

# Named variant of above
p_hello_named = _sre.compile(
    "(?P<first>hello)(?:(?P<second>world)|)", 0, hello_opt_code, 2,
    {'first': 1, 'second': 2},
    (None, 'first', 'second')
)

# (.)=(.) (2 groups) - for findall multi-group
dotequal_code = [14, 4, 0, 3, 3, 17, 0, 2, 17, 1, 16, 61, 17, 2, 2, 17, 3, 1]
p_dotequal = _sre.compile("(.)=(.)", 0, dotequal_code, 2, {}, ())

# (ab)(cd) (2 groups)
abcd_code = [14, 14, 1, 4, 4, 4, 0, 97, 98, 99, 100, 0, 0, 0, 0, 17, 0, 16, 97, 16, 98, 17, 1, 17, 2, 16, 99, 16, 100, 17, 3, 1]
p_abcd = _sre.compile("(ab)(cd)", 0, abcd_code, 2, {}, ())

# (, ) (1 group) - capturing separator for split
sep_code = [14, 10, 1, 2, 2, 2, 0, 44, 32, 0, 0, 17, 0, 16, 44, 16, 32, 17, 1, 1]
p_sep = _sre.compile("(, )", 0, sep_code, 1, {}, ())

# ,  (0 groups) - non-capturing separator for split
sep_nc_code = [14, 10, 3, 2, 2, 2, 2, 44, 32, 0, 0, 16, 44, 16, 32, 1]
p_sep_nc = _sre.compile(", ", 0, sep_nc_code, 0, {}, ())

# ============================================================================
# 1. pos/endpos arguments
# ============================================================================

# search with pos
m = p_hello.search('hello world hello', 1)
assert m is not None, "search pos=1 should find second hello"
assert m.group() == 'hello', f"expected 'hello' got '{m.group()}'"
assert m.start() == 12, f"expected start=12 got {m.start()}"
print("search pos=1:", m.group(), "at", m.start())

# search with pos and endpos
m = p_hello.search('hello world hello', 0, 5)
assert m is not None, "search pos=0 endpos=5 should match"
assert m.group() == 'hello', f"expected 'hello' got '{m.group()}'"
print("search pos=0 endpos=5:", m.group())

# search endpos too short to match
m = p_hello.search('hello world', 0, 4)
assert m is None, "search endpos=4 should not match 5-char pattern"
print("search endpos=4: None (correct)")

# match with pos
m = p_hello.match('say hello', 4)
assert m is not None, "match pos=4 should match"
assert m.group() == 'hello', f"expected 'hello' got '{m.group()}'"
print("match pos=4:", m.group())

# match with endpos
m = p_hello.match('helloworld', 0, 5)
assert m is not None, "match endpos=5 should match"
assert m.group() == 'hello', f"expected 'hello' got '{m.group()}'"
print("match endpos=5:", m.group())

# fullmatch with pos
m = p_hello.fullmatch('say hello', 4)
assert m is not None, "fullmatch pos=4 should match"
assert m.group() == 'hello', f"expected 'hello' got '{m.group()}'"
print("fullmatch pos=4:", m.group())

# fullmatch with pos/endpos
m = p_hello.fullmatch('say hello world', 4, 9)
assert m is not None, "fullmatch pos=4 endpos=9 should match"
assert m.group() == 'hello', f"expected 'hello' got '{m.group()}'"
print("fullmatch pos=4 endpos=9:", m.group())

# findall with pos
result = p_hello.findall('hello world hello', 1)
assert result == ['hello'], f"findall pos=1: expected ['hello'] got {result}"
print("findall pos=1:", result)

# findall with pos and endpos
result = p_hello.findall('hello world hello', 0, 5)
assert result == ['hello'], f"findall pos=0 endpos=5: expected ['hello'] got {result}"
print("findall pos=0 endpos=5:", result)

# finditer with pos
matches = [m.group() for m in p_hello.finditer('hello world hello', 1)]
assert matches == ['hello'], f"finditer pos=1: expected ['hello'] got {matches}"
print("finditer pos=1:", matches)

print("pos/endpos OK")

# ============================================================================
# 2. groups(default=)
# ============================================================================

m = p_hello_opt.match('hello')
assert m is not None
g = m.groups()
assert g[0] == 'hello', f"group 1 = {g[0]}"
assert g[1] is None, f"group 2 should be None, got {g[1]}"
print("groups():", g)

g = m.groups('N/A')
assert g[0] == 'hello'
assert g[1] == 'N/A', f"groups(default='N/A'): group 2 = {g[1]}"
print("groups(default='N/A'):", g)

g = m.groups(0)
assert g[0] == 'hello'
assert g[1] == 0, f"groups(default=0): group 2 = {g[1]}"
print("groups(default=0):", g)
print("groups(default=) OK")

# ============================================================================
# 3. groupdict(default=)
# ============================================================================

m = p_hello_named.match('hello')
assert m is not None
d = m.groupdict()
assert d['first'] == 'hello', f"first = {d['first']}"
assert d['second'] is None, f"second should be None, got {d['second']}"
print("groupdict():", d)

d = m.groupdict('N/A')
assert d['first'] == 'hello'
assert d['second'] == 'N/A', f"groupdict(default='N/A'): second = {d['second']}"
print("groupdict(default='N/A'):", d)
print("groupdict(default=) OK")

# ============================================================================
# 4. findall multi-group
# ============================================================================

result = p_dotequal.findall('a=1 b=2 c=3')
assert len(result) == 3, f"expected 3 results, got {len(result)}"
assert result[0] == ('a', '1'), f"result[0] = {result[0]}"
assert result[1] == ('b', '2'), f"result[1] = {result[1]}"
assert result[2] == ('c', '3'), f"result[2] = {result[2]}"
print("findall (.)=(.):", result)

result = p_abcd.findall('abcd__abcd__abcd')
assert len(result) == 3, f"expected 3 abcd results, got {len(result)}"
assert result[0] == ('ab', 'cd'), f"abcd result[0] = {result[0]}"
print("findall (ab)(cd):", result)
print("findall multi-group OK")

# ============================================================================
# 5. split capturing groups
# ============================================================================

result = p_sep.split('one, two, three')
expected = ['one', ', ', 'two', ', ', 'three']
assert result == expected, f"split capture: expected {expected} got {result}"
print("split capture:", result)

result = p_sep_nc.split('one, two, three')
expected_nc = ['one', 'two', 'three']
assert result == expected_nc, f"split non-capture: expected {expected_nc} got {result}"
print("split non-capture:", result)

result = p_sep.split('one, two, three', 1)
expected_ms = ['one', ', ', 'two, three']
assert result == expected_ms, f"split maxsplit=1: expected {expected_ms} got {result}"
print("split capture maxsplit=1:", result)
print("split capturing groups OK")

# ============================================================================
# 6. _sre.template
# ============================================================================

t = _sre.template("hello", ["world"])
assert t is not None, "template returned None"
print("template: OK")

print("All SRE gap tests passed!")
